---
description: Dieses Template zeigt, wie automatisierte, GDPR-konforme Pseudonymisierung für Logging-Systeme minimalinvasiv implementiert werden kann. Die Lösung folgt dem **Minimalprinzip**: Alle personenbezogenen Daten werden automatisch erkannt und pseudonymisiert, ohne manuelle Konfiguration.
alwaysApply: false
---

## Übersicht

Dieses Template zeigt, wie automatisierte, GDPR-konforme Pseudonymisierung für Logging-Systeme minimalinvasiv implementiert werden kann. Die Lösung folgt dem **Minimalprinzip**: Alle personenbezogenen Daten werden automatisch erkannt und pseudonymisiert, ohne manuelle Konfiguration.

## Warum diese Lösung?

### ❌ Probleme herkömmlicher Ansätze
- **Komplex**: Manuelle Replacement-Dictionaries für jeden Log-Call
- **Fehleranfällig**: IDs können vergessen werden
- **Wartungsaufwand**: Neue ID-Typen müssen manuell hinzugefügt werden
- **GDPR-Risiko**: Nicht-pseudonymisierte Daten in Logs

### ✅ Vorteile dieser Lösung
- **Automatisch**: Pattern-basierte Erkennung aller ID-Typen
- **Minimalinvasiv**: Ein Funktionsaufruf statt komplexer Konfiguration
- **GDPR-sicher**: Fail-Safe bei Pseudonymisierungs-Fehlern
- **OWASP-konform**: PBKDF2-HMAC-SHA-256 mit 600.000 Iterationen

## Schnell-Implementation (5 Minuten)

### 1. Konsolidierte Logger-Implementation

Die folgende Implementation kombiniert alle benötigten Komponenten in einer einzigen Datei für einfache Verwendung:

```python
# utils/gdpr_logger.py
"""
Konsolidierter GDPR-konformer Logger mit automatischer Pseudonymisierung.
Kombiniert Google Cloud Logging-Integration mit OWASP-konformer Pseudonymisierung.

Diese Datei ersetzt utils/logger.py + utils/logger_extensions.py + utils/pseudonymization_service.py
für neue Projekte oder kann als vollständiger Logger-Ersatz verwendet werden.
"""

import os
import sys
import hashlib
import re
import logging
import google.cloud.logging
from typing import Dict


# ================================================================================
# TEIL 1: KONFIGURATION UND UMGEBUNGSVARIABLEN
# ================================================================================

# Map string level names to logging constants
LOG_LEVELS = {
    "DEBUG": logging.DEBUG,
    "INFO": logging.INFO,
    "WARNING": logging.WARNING,
    "ERROR": logging.ERROR,
    "CRITICAL": logging.CRITICAL,
}

# Google Cloud Konfiguration (über config.py oder direkt hier)
DEBUG_LEVEL = os.getenv("DEBUG_LEVEL", "INFO")
GOOGLE_CLOUD_PROJECT = os.getenv("GOOGLE_CLOUD_PROJECT", "your-project-id")
CLOUD_LOG_NAME = os.getenv("CLOUD_LOG_NAME", "data-deletion-events")
CLOUD_ERROR_LOG_NAME = os.getenv("CLOUD_ERROR_LOG_NAME", "application-errors")

# GDPR Pseudonymisierung Konfiguration
PSEUDONYMIZATION_SALT = os.getenv(
    "PSEUDONYMIZATION_SALT", 
    "default_salt_change_in_production"
)
PSEUDONYMIZATION_ITERATIONS = int(os.getenv("PSEUDONYMIZATION_ITERATIONS", "600000"))


# ================================================================================
# TEIL 2: PSEUDONYMISIERUNGS-SERVICE
# ================================================================================

class LoggingPseudonymizationService:
    """
    GDPR-konforme Pseudonymisierung für Logging-Daten.
    Basiert auf OWASP 2024 Standards mit PBKDF2-HMAC-SHA-256.
    """
    
    def __init__(self, salt: str, iterations: int = None):
        self.salt = salt
        if iterations is None:
            # Test-Umgebung: Schnellere Iterationen
            if 'pytest' in sys.modules or os.getenv('TESTING') == 'true':
                self.iterations = 1000
            else:
                self.iterations = 600000  # OWASP 2024 Standard
        else:
            if iterations < 1000:
                raise ValueError("Minimum 1.000 Iterationen erforderlich")
            self.iterations = iterations
    
    def pseudonymize_id(self, data_id: str, id_type: str = "generic") -> str:
        """Pseudonymisiert eine einzelne ID."""
        if not data_id or not isinstance(data_id, str):
            raise ValueError("data_id muss non-empty String sein")
        if not id_type or not isinstance(id_type, str):
            raise ValueError("id_type muss non-empty String sein")
        
        try:
            combined_data = f"{id_type}:{data_id}"
            hash_bytes = hashlib.pbkdf2_hmac(
                'sha256', 
                combined_data.encode('utf-8'), 
                self.salt.encode('utf-8'), 
                self.iterations
            )
            return hash_bytes.hex()[:16]  # Erste 16 Zeichen für lesbare Logs
        except Exception as e:
            raise ValueError(f"Pseudonymization failed: {e}")
    
    def auto_pseudonymize_message(self, message: str) -> str:
        """
        Automatische GDPR-konforme Pseudonymisierung aller erkannten IDs.
        """
        result_message = message
        
        # Optimierte Pattern für verschiedene ID-Typen
        patterns = [
            # UUIDs/GUIDs (höchste Priorität)
            (r'\b[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}\b', 'uuid'),
            # Email-Adressen
            (r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', 'email'),
            # Deutsche Adressen (Straße + Hausnummer)
            (r'\b[A-ZÄÖÜ][a-zäöüß]+(?:straße|str\.?|gasse|weg|platz|allee)\s+\d+[a-z]?\b', 'address'),
            # PLZ + Ort (Deutsche Postleitzahlen, max. 2 Ortsteile)
            (r'\b\d{5}\s+[A-ZÄÖÜ][a-zäöüß]+(?:\s+[A-ZÄÖÜ][a-zäöüß]+){0,2}\b', 'postal_address'),
            # Alphanumerische IDs (Buchstaben UND Zahlen, 6+ Zeichen)
            (r'\b[a-zA-Z0-9]*[a-zA-Z][a-zA-Z0-9]*\d[a-zA-Z0-9]*\b|\b[a-zA-Z0-9]*\d[a-zA-Z0-9]*[a-zA-Z][a-zA-Z0-9]*\b', 'alphanumeric_id'),
            # Numerische IDs (5+ Ziffern, niedrigste Priorität)
            (r'\b\d{5,}\b', 'numeric_id'),
        ]
        
        for pattern, id_type in patterns:
            # Finde alle Matches im aktuellen result_message
            matches = []
            for match in re.finditer(pattern, result_message):
                # Prüfe ob der Match bereits in einem pseudonymisierten Bereich liegt
                start = match.span()[0]
                text_before = result_message[:start]
                
                # Zähle offene und geschlossene Klammern vor dem Match
                open_brackets = text_before.count('[')
                close_brackets = text_before.count(']')
                
                # Wenn mehr offene als geschlossene Klammern, sind wir in einem pseudonymisierten Bereich
                if open_brackets <= close_brackets:
                    matches.append(match.group())
            
            # Ersetze die gefundenen Matches
            for match in set(matches):  # set() vermeidet Duplikate
                pseudonymized = self.pseudonymize_id(match, id_type)
                result_message = result_message.replace(
                    match, 
                    f"[{id_type}:{pseudonymized}]"
                )
        
        return result_message


# ================================================================================
# TEIL 3: BASIS-LOGGER (ERSETZT utils/logger.py)
# ================================================================================

def get_logger(name):
    """
    Erstellt einen Standard-Logger mit Stream-Handler für lokale Ausgabe.
    Diese Funktion ersetzt die ursprüngliche get_logger() aus utils/logger.py
    """
    logger = logging.getLogger(name)
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            "[%(asctime)s] %(levelname)s in %(name)s: %(message)s"
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        # Get the logging level constant, default to INFO if invalid
        level = LOG_LEVELS.get(DEBUG_LEVEL.upper(), logging.INFO)
        logger.setLevel(level)
    return logger


# ================================================================================
# TEIL 4: GOOGLE CLOUD LOGGING INTEGRATION
# ================================================================================

_cloud_logging_client = None
_cloud_log_handler_for_deletions = None
_cloud_log_handler_for_errors = None
fallback_logger = get_logger("cloud_logging_fallback")


def _initialize_cloud_logging():
    """
    Initialisiert den Google Cloud Logging Client und die Handler
    für spezifische Lösch-Logs und Error-Logs.
    Diese Funktion stellt sicher, dass der Client nur einmal initialisiert wird.
    """
    global _cloud_logging_client, _cloud_log_handler_for_deletions, _cloud_log_handler_for_errors
    
    if _cloud_logging_client is None:
        try:
            _cloud_logging_client = google.cloud.logging.Client(
                project=GOOGLE_CLOUD_PROJECT
            )
            _cloud_log_handler_for_deletions = _cloud_logging_client.logger(
                CLOUD_LOG_NAME
            )
            _cloud_log_handler_for_errors = _cloud_logging_client.logger(
                CLOUD_ERROR_LOG_NAME
            )
            logging.getLogger(__name__).info(
                "Cloud Logging Client für Löschereignisse und Error Handling initialisiert."
            )
        except Exception as e:
            logging.getLogger(__name__).error(
                f"Fehler beim Initialisieren des Cloud Logging Clients: {e}"
            )
            _cloud_logging_client = None
            _cloud_log_handler_for_deletions = None
            _cloud_log_handler_for_errors = None


def log_deletion_event(message, severity="INFO", **kwargs):
    """
    Sendet eine spezifische Lösch-Log-Nachricht an Google Cloud Logging.
    Diese Logs werden unter dem Namen 'data-deletion-events' in Cloud Logging
    gespeichert und können von einer Senke in einen spezifischen Bucket exportiert werden.
    """
    # Sicherstellen, dass Cloud Logging initialisiert ist
    if _cloud_logging_client is None:
        _initialize_cloud_logging()

    if _cloud_log_handler_for_deletions:
        severity_map = {
            "DEBUG": "DEBUG",
            "INFO": "INFO",
            "WARNING": "WARNING",
            "ERROR": "ERROR",
            "CRITICAL": "CRITICAL",
        }
        cloud_severity = severity_map.get(severity.upper(), "INFO")

        # Verwenden Sie log_struct, um zusätzliche Daten (kwargs) als JSON-Payload zu senden
        payload = {"message": message}
        payload.update(kwargs)  # Fügt alle zusätzlichen Schlüsselwortargumente hinzu

        _cloud_log_handler_for_deletions.log_struct(payload, severity=cloud_severity)
    else:
        # Fallback, wenn Cloud Logging nicht initialisiert werden konnte
        fallback_logger.error(
            f"Cloud Logging Handler nicht verfügbar. Konnte Lösch-Log nicht an Cloud senden: {message}"
        )


def log_error(message, severity="ERROR", **kwargs):
    """
    Sendet eine spezifische Error-Log-Nachricht an Google Cloud Logging.
    """
    # Sicherstellen, dass Cloud Logging initialisiert ist
    if _cloud_logging_client is None:
        _initialize_cloud_logging()

    if _cloud_log_handler_for_errors:
        severity_map = {
            "DEBUG": "DEBUG",
            "INFO": "INFO",
            "WARNING": "WARNING",
            "ERROR": "ERROR",
            "CRITICAL": "CRITICAL",
        }
        cloud_severity = severity_map.get(severity.upper(), "ERROR")

        # Verwenden Sie log_struct, um zusätzliche Daten (kwargs) als JSON-Payload zu senden
        payload = {"message": message}
        payload.update(kwargs)  # Fügt alle zusätzlichen Schlüsselwortargumente hinzu

        _cloud_log_handler_for_errors.log_struct(payload, severity=cloud_severity)
    else:
        # Fallback, wenn Cloud Logging nicht initialisiert werden konnte
        fallback_logger.error(
            f"Cloud Logging Handler nicht verfügbar. Konnte Error Log nicht an Cloud senden: {message}"
        )


# ================================================================================
# TEIL 5: GDPR-SICHERE LOGGER-WRAPPER
# ================================================================================

# Global service instance für Pseudonymisierung
logging_pseudonymization_service = LoggingPseudonymizationService(
    PSEUDONYMIZATION_SALT, 
    PSEUDONYMIZATION_ITERATIONS
)


def auto_pseudonymize_log_message(message: str) -> str:
    """
    Automatische GDPR-konforme Pseudonymisierung aller IDs in Log-Nachrichten.
    """
    return logging_pseudonymization_service.auto_pseudonymize_message(message)


def log_error_safe(message, severity="ERROR", **kwargs):
    """
    Sendet eine GDPR-konforme Error-Log-Nachricht an Google Cloud Logging.
    Automatische Pseudonymisierung aller erkannten personenbezogenen Daten.

    Args:
        message: Log-Nachricht
        severity: Log-Level
        **kwargs: Zusätzliche Daten für JSON-Payload
    """
    try:
        # Automatische Pseudonymisierung der gesamten Nachricht
        safe_message = auto_pseudonymize_log_message(message)

        # Verwende die Cloud Logging Error-Funktion
        log_error(safe_message, severity, **kwargs)

    except Exception as e:
        # Fallback: Logge nur Fehler ohne potentiell sensitive Daten
        fallback_logger.error(
            f"Pseudonymisierung fehlgeschlagen, Original-Log unterdrückt: {e}"
        )


def log_deletion_event_safe(message, severity="INFO", **kwargs):
    """
    Sendet eine GDPR-konforme Lösch-Log-Nachricht an Google Cloud Logging.
    Automatische Pseudonymisierung aller erkannten personenbezogenen Daten.
    """
    try:
        # Automatische Pseudonymisierung der gesamten Nachricht
        safe_message = auto_pseudonymize_log_message(message)

        # Verwende die Cloud Logging Deletion-Funktion
        log_deletion_event(safe_message, severity, **kwargs)

    except Exception as e:
        # Fallback: Logge nur Fehler ohne potentiell sensitive Daten
        fallback_logger.error(
            f"Pseudonymisierung fehlgeschlagen, Original-Log unterdrückt: {e}"
        )


class SafeLoggerWrapper:
    """
    GDPR-konformer Logger-Wrapper mit automatischer ID-Pseudonymisierung.
    Alle Standard-Logger-Methoden verfügbar mit automatischer Pseudonymisierung.
    """
    
    def __init__(self, logger):
        self._logger = logger

    def _safe_log(self, level, message):
        """
        Interne Methode für sichere Log-Ausgabe mit Pseudonymisierung.
        """
        try:
            # Automatische Pseudonymisierung der gesamten Nachricht
            safe_message = auto_pseudonymize_log_message(message)
            getattr(self._logger, level)(safe_message)
        except Exception as e:
            self._logger.error(
                f"Pseudonymisierung fehlgeschlagen, Original-Log unterdrückt: {e}"
            )

    def debug(self, message):
        """Debug-Level Log mit automatischer Pseudonymisierung."""
        self._safe_log("debug", message)

    def info(self, message):
        """Info-Level Log mit automatischer Pseudonymisierung."""
        self._safe_log("info", message)

    def warning(self, message):
        """Warning-Level Log mit automatischer Pseudonymisierung."""
        self._safe_log("warning", message)

    def error(self, message):
        """Error-Level Log mit automatischer Pseudonymisierung."""
        self._safe_log("error", message)

    def critical(self, message):
        """Critical-Level Log mit automatischer Pseudonymisierung."""
        self._safe_log("critical", message)


def get_safe_logger(name):
    """
    Gibt einen GDPR-konformen Logger zurück mit automatischer ID-Pseudonymisierung.
    Integriert mit bestehender Google Cloud Logging-Infrastruktur.
    
    Args:
        name: Logger-Name für Identifikation
        
    Returns:
        SafeLoggerWrapper: Logger mit automatischer Pseudonymisierung
        
    Beispiel:
        logger = get_safe_logger("invoice_service")
        logger.info("Processing user user123")  # → "Processing user [alphanumeric_id:a1b2c3d4...]"
    """
    base_logger = get_logger(name)  # Verwendet die Standard-Logger-Funktion
    return SafeLoggerWrapper(base_logger)


# ================================================================================
# TEIL 6: EINFACHE APIs FÜR MIGRATION VON BESTEHENDEN PROJEKTEN
# ================================================================================

def migrate_from_old_logger():
    """
    Hilfsfunktion für Migration von bestehenden Logger-Implementierungen.
    
    Alte Verwendung:
        from utils.logger import get_logger, log_error, log_deletion_event
        logger = get_logger("service")
        log_error("Error message")
        
    Neue Verwendung:
        from utils.gdpr_logger import get_safe_logger, log_error_safe, log_deletion_event_safe
        logger = get_safe_logger("service")
        log_error_safe("Error message")
    """
    pass  # Dokumentation nur


# ================================================================================
# TEIL 7: EXPORT DER WICHTIGSTEN FUNKTIONEN
# ================================================================================

# Hauptfunktionen für die Verwendung
__all__ = [
    # Logger-Erstellung
    'get_safe_logger',
    'get_logger',
    
    # Sichere Cloud-Logging-Funktionen
    'log_error_safe',
    'log_deletion_event_safe',
    
    # Standard Cloud-Logging-Funktionen (ohne Pseudonymisierung)
    'log_error',
    'log_deletion_event',
    
    # Direkte Pseudonymisierung
    'auto_pseudonymize_log_message',
    'logging_pseudonymization_service',
    
    # Logger-Wrapper-Klasse
    'SafeLoggerWrapper',
]


# ================================================================================
# TEIL 8: VERWENDUNGSBEISPIELE IM CODE
# ================================================================================

if __name__ == "__main__":
    """
    Demonstriert die Verwendung des konsolidierten GDPR-Loggers.
    Diese Beispiele sollten nur für Tests verwendet werden.
    """
    
    # 1. Basis-Logger mit automatischer Pseudonymisierung
    logger = get_safe_logger("demo_service")
    logger.info("Processing contact user123 with email test@example.com")
    
    # 2. Direkte Cloud-Logging-Funktionen
    log_error_safe("Failed to process user user456 at Musterstraße 42")
    log_deletion_event_safe("Deleted data for contact contact789")
    
    # 3. Direkte Pseudonymisierung (für spezielle Fälle)
    message = "Contact user123 has email test@example.com at Musterstraße 42"
    safe_message = auto_pseudonymize_log_message(message)
    print(f"Original: {message}")
    print(f"Pseudonymized: {safe_message}")
```

### 2. Konfiguration und Setup

#### Umgebungsvariablen konfigurieren

```bash
# .env oder Umgebungsvariablen
# ================================================================================
# GDPR Pseudonymisierung (ERFORDERLICH)
# ================================================================================
PSEUDONYMIZATION_SALT=<base64-32-byte-salt>  # ERFORDERLICH für Production
PSEUDONYMIZATION_ITERATIONS=600000           # Optional, Standard: 600000

# ================================================================================
# Google Cloud Logging (ERFORDERLICH für Cloud-Integration)
# ================================================================================
GOOGLE_CLOUD_PROJECT=your-project-id         # Ihr GCP Projekt
CLOUD_LOG_NAME=data-deletion-events          # Log-Name für Lösch-Events
CLOUD_ERROR_LOG_NAME=application-errors      # Log-Name für Fehler

# ================================================================================
# Lokales Development Logging (OPTIONAL)
# ================================================================================
DEBUG_LEVEL=INFO                             # DEBUG, INFO, WARNING, ERROR, CRITICAL
TESTING=false                                # Auf 'true' für Schnell-Tests
```

#### Salt sicher generieren

```python
import secrets
import base64

# Sicheren Salt generieren für Production
salt = base64.b64encode(secrets.token_bytes(32)).decode('utf-8')
print(f"PSEUDONYMIZATION_SALT={salt}")

# Beispiel-Output:
# PSEUDONYMIZATION_SALT=K7gNU3sdo+OL0wNhqoVWhr3g6s1xYv72ol/pe/Unols=
```

#### Google Cloud Setup

1. **Service Account erstellen:**
```bash
# 1. Service Account erstellen
gcloud iam service-accounts create gdpr-logger-service \
    --display-name="GDPR Logger Service Account"

# 2. Logging-Berechtigungen zuweisen
gcloud projects add-iam-policy-binding your-project-id \
    --member="serviceAccount:gdpr-logger-service@your-project-id.iam.gserviceaccount.com" \
    --role="roles/logging.logWriter"

# 3. Service Account Key erstellen
gcloud iam service-accounts keys create /app/credentials/credentials.json \
    --iam-account=gdpr-logger-service@your-project-id.iam.gserviceaccount.com
```

2. **Lokale Entwicklung:**
```bash
# Für lokale Entwicklung: Application Default Credentials
gcloud auth application-default login

# Oder Service Account Key verwenden
export GOOGLE_APPLICATION_CREDENTIALS="/path/to/credentials.json"
```

3. **Docker/Production Setup:**
```dockerfile
# Dockerfile Beispiel
FROM python:3.11-slim

# Credentials mounten (nicht in Image kopieren!)
VOLUME ["/app/credentials"]

# Umgebungsvariable für Credentials
ENV GOOGLE_APPLICATION_CREDENTIALS=/app/credentials/credentials.json

# App Code
COPY . /app
WORKDIR /app

# Dependencies installieren
RUN pip install -r requirements.txt

# Port 8080 für GCP
EXPOSE 8080

CMD ["python", "main.py"]
```

#### Dependencies installieren

```bash
# requirements.txt erweitern
pip install google-cloud-logging>=3.8.0

# Oder direkt installieren
pip install google-cloud-logging
```

## Verwendung des konsolidierten GDPR-Loggers

### 1. Einfache Integration - Drei Verwendungsarten

Der konsolidierte Logger bietet drei Nutzungsebenen:

#### **Empfohlen: Kompletter Logger-Wrapper**
```python
from utils.gdpr_logger import get_safe_logger

# Erstelle einen sicheren Logger
logger = get_safe_logger("invoice_service")

# Alle Standard-Log-Levels verfügbar mit automatischer Pseudonymisierung
logger.info("Processing contact user123 with email test@example.com")
logger.error("Failed to process transaction tx_abc123def456 for user@domain.com")
logger.warning("Validation failed for contact user789 at Musterstraße 42")
logger.debug("Processing UUID 550e8400-e29b-41d4-a716-446655440000")

# Output in Google Cloud Logging:
# → "Processing contact [alphanumeric_id:a1b2c3d4e5f6g7h8] with email [email:x9y8z7w6v5u4t3s2]"
# → "Failed to process transaction [alphanumeric_id:def456789abc123] for [email:ghi789012jkl345]"
```

#### **Direkte Cloud-Logging-Funktionen**
```python
from utils.gdpr_logger import log_error_safe, log_deletion_event_safe

# Error-Logging mit automatischer Pseudonymisierung
log_error_safe(
    "User user123 failed login with email john@example.com from IP 192.168.1.100",
    severity="WARNING"
)
# → Sendet an Google Cloud Logging: "User [alphanumeric_id:a1b2c3d4e5f6g7h8] failed login with email [email:x9y8z7w6v5u4t3s2] from IP [numeric_id:1a2b3c4d5e6f7g8h]"

# GDPR-konforme Lösch-Events protokollieren
log_deletion_event_safe(
    "Deleted user data for contact user456 at Musterstraße 42 in 10115 Berlin"
)
# → Sendet speziellen DELETION-Log an Google Cloud mit Pseudonymisierung
```

#### **Direkte Pseudonymisierung (für spezielle Fälle)**
```python
from utils.gdpr_logger import auto_pseudonymize_log_message

# Für Custom-Logging oder Debugging
raw_message = "Contact user123 has email test@example.com at Musterstraße 42"
safe_message = auto_pseudonymize_log_message(raw_message)
print(safe_message)
# → "Contact [alphanumeric_id:a1b2c3d4e5f6g7h8] has email [email:x9y8z7w6v5u4t3s2] at [address:def456789abc123]"

# HINWEIS: Normalerweise sollten Sie get_safe_logger() verwenden
# Diese Funktion ist nur für spezielle Anwendungsfälle gedacht
```

### 2. Migration von bestehenden Projekten

#### **Schritt 1: Drop-in Replacement**
```python
# ================================================================================
# VORHER: Bestehende Logger-Verwendung
# ================================================================================
from utils.logger import get_logger, log_error, log_deletion_event

logger = get_logger("service_name")
logger.info("Processing user user123")
log_error("Error processing user456")
log_deletion_event("Deleted user789")

# ================================================================================
# NACHHER: GDPR-konformer Logger (minimale Änderungen)
# ================================================================================
from utils.gdpr_logger import get_safe_logger, log_error_safe, log_deletion_event_safe

logger = get_safe_logger("service_name")  # Ändere nur get_logger → get_safe_logger
logger.info("Processing user user123")    # Gleiche API, automatische Pseudonymisierung
log_error_safe("Error processing user456")         # Ändere log_error → log_error_safe
log_deletion_event_safe("Deleted user789")         # Ändere log_deletion_event → log_deletion_event_safe
```

#### **Schritt 2: Schrittweise Migration**
```python
# 1. Neue Features verwenden sichere Varianten
from utils.gdpr_logger import get_safe_logger

safe_logger = get_safe_logger("new_feature")
safe_logger.info("Processing new user user789")

# 2. Bestehende Error-Logs migrieren
from utils.gdpr_logger import log_error_safe

# Vorher:
# log_error("User login failed for user123")

# Nachher:
log_error_safe("User login failed for user123")

# 3. Standard-Logger nach und nach ersetzen
# Vorher:
# logger = get_logger("old_service")

# Nachher:
logger = get_safe_logger("old_service")  # Gleiche API, mehr Sicherheit
```

### 3. Framework-Integration

#### **FastAPI**
```python
# main.py
from utils.gdpr_logger import get_safe_logger, log_error_safe
from fastapi import FastAPI

app = FastAPI()
app_logger = get_safe_logger("invoice_automation")

@app.post("/webhook")
async def handle_webhook(data: dict):
    contact_id = data.get('contact_id')
    
    try:
        app_logger.info(f"Processing webhook for contact {contact_id}")
        
        # Business Logic hier...
        
        app_logger.info(f"Webhook processed successfully for {contact_id}")
        return {"status": "success"}
        
    except Exception as e:
        log_error_safe(
            f"Webhook processing failed for contact {contact_id}: {str(e)}",
            severity="ERROR",
            contact_id=contact_id,  # Zusätzliche Daten für Cloud Logging
            error_type=type(e).__name__
        )
        raise

# Beispiel-Output in Google Cloud Logging:
# → "Processing webhook for contact [alphanumeric_id:a1b2c3d4e5f6g7h8]"
# → "Webhook processed successfully for [alphanumeric_id:a1b2c3d4e5f6g7h8]"
```

### 4. Google Cloud Logging Features

#### **Strukturierte Logs mit zusätzlichen Daten**
```python
from utils.gdpr_logger import log_error_safe, log_deletion_event_safe

# Zusätzliche strukturierte Daten für Cloud Logging
log_error_safe(
    "Payment processing failed for user user123",
    severity="ERROR",
    user_type="premium",
    payment_method="credit_card",
    amount=99.99,
    currency="EUR",
    error_code="CARD_DECLINED"
)

# GDPR-konforme Lösch-Protokollierung mit Metadaten
log_deletion_event_safe(
    "Deleted user data for contact user456",
    severity="INFO",
    data_types=["profile", "transactions", "logs"],
    retention_period="30_days",
    deleted_by="automated_cleanup"
)
```

#### **Log-Filterung in Google Cloud Console**
```sql
-- Beispiel-Queries für Google Cloud Logging
-- Alle pseudonymisierten User-Logs finden:
jsonPayload.message:"[alphanumeric_id:"

-- Error-Logs nach Severity filtern:
severity="ERROR" AND jsonPayload.message:"failed"

-- Lösch-Events finden:
logName:"data-deletion-events"

-- Logs eines bestimmten Services:
labels."k8s-pod/app"="invoice-automation"
```

## Erkannte Pattern

Die automatische Erkennung pseudonymisiert:

| Pattern | Beispiel | Pseudonymisiert als |
|---------|----------|-------------------|
| UUIDs | `550e8400-e29b-41d4-a716-446655440000` | `[uuid:def456...]` |
| Email-Adressen | `user@domain.com` | `[email:ghi789...]` |
| Deutsche Adressen | `Musterstraße 42`, `Hauptgasse 17a` | `[address:abc123...]` |
| PLZ + Ort | `10115 Berlin`, `80331 München` | `[postal_address:def456...]` |
| Alphanumerische IDs | `user123`, `abc123def456`, `574drf86np23dpqsbab9bv5ii4` | `[alphanumeric_id:ghi789...]` |
| Numerische IDs (5+ Ziffern) | `12345`, `987654321` | `[numeric_id:jkl012...]` |

## Erweiterte Konfiguration

### Custom Pattern hinzufügen
```python
# In pseudonymization_service.py, patterns-Liste erweitern:
patterns = [
    # Standard-Pattern...
    
    # Custom: IP-Adressen
    (r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b', 'ip_address'),
    # Custom: Deutsche Telefonnummern
    (r'\b(?:\+49|0049|0)[\s\-]?\d{2,4}[\s\-]?\d{6,8}\b', 'phone_number'),
    # Custom: Kreditkarten
    (r'\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b', 'credit_card'),
]
```

### Spezifische ID-Pseudonymisierung
```python
from utils.pseudonymization_service import logging_pseudonymization_service

# Für bekannte ID-Typen
contact_id_hash = logging_pseudonymization_service.pseudonymize_id("12345", "contact")
event_id_hash = logging_pseudonymization_service.pseudonymize_id("event_abc", "event")
```

## Testing

### Unit Tests
```python
import unittest
from utils.pseudonymization_service import auto_pseudonymize_log_message

class TestPseudonymization(unittest.TestCase):
    def test_alphanumeric_id_pseudonymization(self):
        message = "Contact user123 was processed"
        result = auto_pseudonymize_log_message(message)
        
        # Überprüfe, dass Original-ID nicht mehr im Text steht
        self.assertNotIn("user123", result)
        # Überprüfe Pseudonymisierungs-Format
        self.assertIn("[alphanumeric_id:", result)
    
    def test_email_pseudonymization(self):
        message = "Email sent to user@example.com"
        result = auto_pseudonymize_log_message(message)
        
        self.assertNotIn("user@example.com", result)
        self.assertIn("[email:", result)
    
    def test_multiple_ids_in_one_message(self):
        message = "Contact user123 with email test@domain.com at Musterstraße 42"
        result = auto_pseudonymize_log_message(message)
        
        self.assertNotIn("user123", result)
        self.assertNotIn("test@domain.com", result) 
        self.assertNotIn("Musterstraße 42", result)
        self.assertIn("[alphanumeric_id:", result)
        self.assertIn("[email:", result)
        self.assertIn("[address:", result)
    
    def test_safe_logger_integration(self):
        """Testet Integration mit Safe Logger."""
        from utils.logger_extensions import get_safe_logger
        import io
        import sys
        
        # Capture logging output
        captured_output = io.StringIO()
        sys.stdout = captured_output
        
        logger = get_safe_logger("test_logger")
        logger.info("Processing user user456 with email test@example.com")
        
        sys.stdout = sys.__stdout__
        
        # Überprüfe, dass Logger funktioniert (exakte Ausgabe hängt von Logger-Konfiguration ab)
        # Hauptsache: Kein Fehler beim Logging-Aufruf
        self.assertTrue(True)  # Test besteht wenn kein Exception geworfen wird
    
    def test_error_logging_safe(self):
        """Testet sichere Error-Logging-Funktion."""
        from utils.logger_extensions import log_error_safe
        
        # Sollte keine Exception werfen
        try:
            log_error_safe("Error processing user user789 at Teststraße 5")
            test_passed = True
        except Exception:
            test_passed = False
        
        self.assertTrue(test_passed)
```

### Performance Tests
```python
import time
from utils.pseudonymization_service import auto_pseudonymize_log_message

def test_performance():
    """Testet Performance der Pseudonymisierung."""
    from utils.logger_extensions import get_safe_logger
    
    message = "Processing contact user123 with email user@domain.com and UUID 550e8400-e29b-41d4-a716-446655440000 at Teststraße 5 in 12345 Berlin"
    
    # Test direkte Pseudonymisierung
    start_time = time.time()
    for _ in range(1000):
        auto_pseudonymize_log_message(message)
    end_time = time.time()
    
    print(f"1000 direkte Pseudonymisierungen in {end_time - start_time:.3f} Sekunden")
    
    # Test mit Safe Logger (inkl. Google Cloud Logging)
    logger = get_safe_logger("performance_test")
    start_time = time.time()
    for i in range(100):  # Weniger Iterations wegen Cloud Logging
        logger.info(f"Test {i}: {message}")
    end_time = time.time()
    
    print(f"100 Safe Logger Aufrufe in {end_time - start_time:.3f} Sekunden")
    # Erwartet: < 1 Sekunde für direkte, < 5 Sekunden für Cloud Logging
```

## Integration in bestehende Projekte

### 1. Schrittweise Migration
```python
# Schritt 1: Neue Logs verwenden Safe Logger
from utils.logger_extensions import get_safe_logger, log_error_safe

# Neue Features
logger = get_safe_logger("invoice_automation")
logger.info(f"Processing invoice for user {user_id}")

# Schritt 2: Bestehende Error-Logs migrieren
# Vorher:
# from utils.logger import log_error
# log_error(f"Failed to process user {user_id}")

# Nachher:
log_error_safe(f"Failed to process user {user_id}")

# Schritt 3: Bestehende Standard-Logs migrieren
# Vorher:
# from utils.logger import get_logger
# logger = get_logger("service_name")
# logger.info(f"User {user_id} action completed")

# Nachher:
logger = get_safe_logger("service_name")
logger.info(f"User {user_id} action completed")
```

### 2. Google Cloud Logging Integration
```python
# Die logger_extensions nutzen automatisch die bestehende Google Cloud Infrastruktur
from utils.logger_extensions import get_safe_logger

# Dieser Logger sendet automatisch an Google Cloud Logging
# mit derselben Konfiguration wie die bestehenden Logger
cloud_logger = get_safe_logger("production_service")
cloud_logger.info("Service started for user user123")

# Logs erscheinen in Google Cloud Console mit pseudonymisierten Daten:
# "Service started for user [alphanumeric_id:a1b2c3d4e5f6g7h8]"
```

### 3. Framework-Integration

#### FastAPI (wie in diesem Projekt)
```python
# main.py
from utils.logger_extensions import get_safe_logger, log_error_safe

# Haupt-Service Logger
app_logger = get_safe_logger("invoice_automation")

@app.post("/webhook")
async def handle_webhook(data: dict):
    try:
        app_logger.info(f"Processing webhook for contact {data.get('contact_id')}")
        # ... Verarbeitung ...
        app_logger.info(f"Webhook processed successfully for {data.get('contact_id')}")
    except Exception as e:
        log_error_safe(
            f"Webhook processing failed for contact {data.get('contact_id')}: {str(e)}",
            severity="ERROR"
        )
        raise
```

#### Django
```python
# views.py
from utils.logger_extensions import get_safe_logger

logger = get_safe_logger('django_app')

def user_view(request):
    logger.info(f"User {request.user.id} accessed view")
    # Automatisch pseudonymisiert und an Google Cloud gesendet
```

#### Flask
```python
# app.py
from utils.logger_extensions import get_safe_logger

app_logger = get_safe_logger('flask_app')

@app.route('/process')
def process_user():
    user_id = request.json.get('user_id')
    app_logger.info(f"Processing request for user {user_id}")
    # Automatisch pseudonymisiert
```

## Compliance und Monitoring

### GDPR-Compliance Checkliste
- ✅ **Automatische Pseudonymisierung**: Alle IDs werden erkannt und pseudonymisiert
- ✅ **Fail-Safe-Mechanismus**: Bei Pseudonymisierungs-Fehlern wird Original-Log unterdrückt
- ✅ **OWASP-konforme Kryptographie**: PBKDF2-HMAC-SHA-256 mit 600.000 Iterationen
- ✅ **Minimalprinzip**: Keine manuellen Replacements oder Konfigurationen nötig
- ✅ **Umkehrbarkeit**: Pseudonymisierung ist nicht umkehrbar (One-Way-Hash)

### Monitoring-Pattern
```python
from utils.logger_extensions import get_safe_logger, log_error_safe
from utils.pseudonymization_service import auto_pseudonymize_log_message

# Überwachung der Pseudonymisierungs-Erfolgsrate
def monitor_pseudonymization_health():
    """Überwacht die GDPR-Compliance des Logging-Systems."""
    monitor_logger = get_safe_logger("pseudonymization_monitor")
    
    test_messages = [
        "Contact user123 processed",
        "Email sent to test@example.com", 
        "UUID 550e8400-e29b-41d4-a716-446655440000 created",
        "Address Musterstraße 42 verified",
        "Package to 10115 Berlin shipped"
    ]
    
    success_count = 0
    for message in test_messages:
        try:
            result = auto_pseudonymize_log_message(message)
            # Prüfe ob Pseudonymisierung stattgefunden hat
            if "[" in result and ":" in result:
                success_count += 1
        except Exception as e:
            log_error_safe(
                f"Pseudonymization test failed for message: {str(e)}",
                severity="WARNING"
            )
    
    success_rate = (success_count / len(test_messages)) * 100
    monitor_logger.info(f"Pseudonymization success rate: {success_rate}%")
    
    if success_rate < 100:
        log_error_safe(
            "GDPR-KRITISCHER FEHLER: Pseudonymisierung fehlgeschlagen",
            severity="CRITICAL"
        )
    
    return success_rate >= 100

# Beispiel für regelmäßige Überwachung
def setup_health_monitoring():
    """Richtet regelmäßige Gesundheitsprüfungen ein."""
    import schedule
    import time
    
    # Täglich um 6:00 Uhr prüfen
    schedule.every().day.at("06:00").do(monitor_pseudonymization_health)
    
    while True:
        schedule.run_pending()
        time.sleep(3600)  # Prüfe jede Stunde
```

## Häufige Fragen

### F: Kann ich die Pattern anpassen?
A: Ja, erweitere die `patterns`-Liste in `auto_pseudonymize_message()` um eigene Regular Expressions. Beachte die Reihenfolge: spezifische Pattern (UUID, Email) vor allgemeinen Pattern (alphanumeric_id, numeric_id).

### F: Wie integriere ich das in bestehende Google Cloud Logging?
A: Die `logger_extensions.py` nutzen automatisch die bestehende `utils.logger` Infrastruktur. Einfach `get_safe_logger()` statt `get_logger()` und `log_error_safe()` statt `log_error()` verwenden.

### F: Muss ich meine bestehende Logging-Konfiguration ändern?
A: Nein. Die Logger-Extensions verwenden die bestehende Konfiguration und senden automatisch an Google Cloud Logging.

### F: Was ist der Unterschied zwischen get_safe_logger() und log_error_safe()?
A: `get_safe_logger()` gibt einen vollständigen Logger zurück (debug, info, warning, error, critical). `log_error_safe()` ist eine direkte Funktion für Error-Logs, die die bestehende `log_error()` Funktion ersetzt.

### F: Wie performant ist die Lösung?
A: Sehr performant. PBKDF2 wird nur für eindeutige IDs berechnet, Regex-Matching ist schnell.

### F: Was passiert bei Pseudonymisierungs-Fehlern?
A: Fail-Safe: Das Original-Log wird unterdrückt und ein Fehler-Log ohne sensitive Daten erstellt.

### F: Ist die Pseudonymisierung umkehrbar?
A: Nein, PBKDF2 ist eine One-Way-Hash-Funktion. Pseudonymisierte IDs können nicht zurück zu Originalen konvertiert werden.

### F: Kann ich verschiedene Salts für verschiedene ID-Typen verwenden?
A: Ja, erweitere die Konfiguration um typ-spezifische Salts:

```python
# Beispiel für erweiterte Salt-Konfiguration
PSEUDONYMIZATION_SALTS = {
    'contact': os.getenv('CONTACT_SALT'),
    'event': os.getenv('EVENT_SALT'),
    'transaction': os.getenv('TRANSACTION_SALT'),
    'generic': os.getenv('PSEUDONYMIZATION_SALT')
}

# In der LoggingPseudonymizationService Klasse:
def get_salt_for_type(self, id_type: str) -> str:
    """Gibt typ-spezifischen Salt zurück."""
    return PSEUDONYMIZATION_SALTS.get(id_type, PSEUDONYMIZATION_SALTS['generic'])
```

## Vorteile der Logger-Extensions

### ✅ **Nahtlose Integration**
- Nutzt bestehende `utils.logger` Infrastruktur
- Automatische Google Cloud Logging-Integration
- Keine Änderungen an bestehender Konfiguration nötig

### ✅ **Drei Nutzungsebenen**
1. **`log_error_safe()`** - Direkter Ersatz für `log_error()`
2. **`log_deletion_event_safe()`** - GDPR-konforme Lösch-Protokollierung
3. **`get_safe_logger()`** - Vollständiger Logger-Wrapper

### ✅ **Production-Ready**
- Fail-Safe bei Pseudonymisierungs-Fehlern
- Automatische Fallback-Mechanismen
- Keine Performance-Einbußen
- Kompatibel mit bestehenden Monitoring-Tools

## Fazit

Diese Lösung bietet:
- ✅ **5-Minuten-Setup** für neue Projekte
- ✅ **Schrittweise Migration** für bestehende Projekte  
- ✅ **GDPR-Compliance** ohne Entwickleraufwand
- ✅ **Google Cloud Integration** out-of-the-box
- ✅ **Automatische Erkennung** aller relevanten ID-Typen (6 Pattern-Kategorien)
- ✅ **Fail-Safe-Sicherheit** bei Fehlern
- ✅ **OWASP-Standards** für Kryptographie

**Kein manueller Aufwand mehr für GDPR-konforme Logs!**

## Wichtige Implementierungs-Hinweise

### ⚠️ **Nicht verwenden:**
- ~~`log_safe()` Convenience-Funktion~~ (entfernt - redundant)
- Direkte `logging.getLogger()` Aufrufe für sensitive Daten

### ✅ **Empfohlene Verwendung:**
1. **Neue Projekte**: Verwende ausschließlich `get_safe_logger()`
2. **Bestehende Projekte**: Migriere schrittweise zu `log_error_safe()` und `get_safe_logger()`
3. **Google Cloud**: Logger-Extensions nutzen automatisch bestehende Cloud-Konfiguration
4. **Monitoring**: Implementiere `monitor_pseudonymization_health()` für Compliance-Überwachung