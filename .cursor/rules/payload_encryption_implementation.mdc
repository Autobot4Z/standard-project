---
description: Diese Anleitung beschreibt die Implementierung einer GDPR-konformen AES-256-GCM Payload-Verschl√ºsselung. Die L√∂sung erm√∂glicht es, sensible Webhook-Daten verschl√ºsselt √ºber Cloud Tasks zu √ºbertragen.
alwaysApply: false
---
# Payload-Verschl√ºsselung Implementation Guide

## √úbersicht

Diese Anleitung beschreibt die Implementierung einer GDPR-konformen AES-256-GCM Payload-Verschl√ºsselung. Die L√∂sung erm√∂glicht es, sensible Webhook-Daten verschl√ºsselt √ºber Cloud Tasks zu √ºbertragen.

## Architektur

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    verschl√ºsselt     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    entschl√ºsselt     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Sender        ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ  Cloud Tasks    ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ   Empf√§nger     ‚îÇ
‚îÇ   (Webhook)     ‚îÇ                      ‚îÇ   Queue         ‚îÇ                      ‚îÇ   (Processor)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## 1. Environment Setup

### 1.1 Verschl√ºsselungsschl√ºssel generieren

```bash
# Einmaliger Befehl zur Schl√ºssel-Generierung
python3 -c "import os, base64; print(base64.urlsafe_b64encode(os.urandom(32)).decode())"
```

### 1.2 Environment Variable setzen

```bash
# In .env Datei
PAYLOAD_ENCRYPTION_KEY=YOUR_GENERATED_KEY_HERE
```

## 2. Dependencies

### 2.1 Requirements.txt erweitern

```python
# In requirements.txt hinzuf√ºgen
cryptography
```

### 2.2 Installation

```bash
pip install cryptography
```

## 3. Sender-Implementation (Verschl√ºsselung)

### 3.1 Encryption Module erstellen

Erstelle `utils/encryption.py` mit folgenden Funktionen:

```python
import base64
import json
import os
from typing import Dict, Any
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend


def encrypt_payload(payload: Dict[Any, Any]) -> str:
    """
    Verschl√ºsselt einen Payload mit AES-256-GCM.
    
    Args:
        payload: Dict der verschl√ºsselt werden soll
        
    Returns:
        str: Base64-kodierter verschl√ºsselter String
    """
    encryption_key = os.getenv("PAYLOAD_ENCRYPTION_KEY")
    if not encryption_key:
        raise ValueError("PAYLOAD_ENCRYPTION_KEY environment variable is required")
    
    try:
        key = base64.urlsafe_b64decode(encryption_key)
        if len(key) != 32:
            raise ValueError("PAYLOAD_ENCRYPTION_KEY must be a 32-byte, base64-encoded key")
    except (ValueError, TypeError) as e:
        raise ValueError(f"Invalid PAYLOAD_ENCRYPTION_KEY: {str(e)}")
    
    # Payload zu JSON String konvertieren
    json_data = json.dumps(payload, ensure_ascii=False)
    
    # Frische 12-Byte IV f√ºr jede Verschl√ºsselung
    iv = os.urandom(12)
    
    # Cipher mit AES-256-GCM erstellen
    encryptor = Cipher(
        algorithms.AES(key),
        modes.GCM(iv),
        backend=default_backend(),
    ).encryptor()
    
    # Verschl√ºsseln
    ciphertext = encryptor.update(json_data.encode("utf-8")) + encryptor.finalize()
    
    # IV + Tag + Ciphertext kombinieren und Base64 kodieren
    encrypted_data = iv + encryptor.tag + ciphertext
    return base64.urlsafe_b64encode(encrypted_data).decode("utf-8")
```

### 3.2 Sender-Service modifizieren

```python
from utils.encryption import encrypt_payload

async def send_encrypted_webhook(payload: dict):
    """Webhook mit verschl√ºsseltem Payload senden"""
    
    # Payload verschl√ºsseln
    encrypted_payload = encrypt_payload(payload)
    
    # Task mit verschl√ºsseltem Payload erstellen
    task = {
        'http_request': {
            'http_method': tasks_v2.HttpMethod.POST,
            'url': webhook_url,
            'headers': {
                'Content-Type': 'text/plain',
                'X-Payload-Encrypted': 'true'  # Wichtiger Header!
            },
            'body': encrypted_payload.encode('utf-8')
        }
    }
    
    # Task zur Queue hinzuf√ºgen
    client.create_task(parent=parent, task=task)
```

## 4. Empf√§nger-Implementation (Entschl√ºsselung)

### 4.1 Decryption Class erstellen

Erg√§nze `utils/encryption.py`:

```python
from cryptography.exceptions import InvalidTag


class PayloadDecryption:
    """GDPR-konforme Entschl√ºsselungslogik f√ºr verschl√ºsselte Payloads."""
    
    def __init__(self):
        encryption_key = os.getenv("PAYLOAD_ENCRYPTION_KEY")
        if not encryption_key:
            raise ValueError("PAYLOAD_ENCRYPTION_KEY environment variable is required")
        
        try:
            self._encryption_key = base64.urlsafe_b64decode(encryption_key)
            if len(self._encryption_key) != 32:
                raise ValueError("PAYLOAD_ENCRYPTION_KEY must be a 32-byte, base64-encoded key")
        except (ValueError, TypeError) as e:
            raise ValueError(f"Invalid PAYLOAD_ENCRYPTION_KEY: {str(e)}")
    
    def decrypt_payload(self, encrypted_data: str) -> Dict[Any, Any]:
        """
        Entschl√ºsselt einen AES-256-GCM verschl√ºsselten Payload.
        
        Args:
            encrypted_data: Base64-kodierter String mit IV + Tag + Ciphertext
            
        Returns:
            Dict: Entschl√ºsselte Payload-Daten
            
        Raises:
            ValueError: Bei ung√ºltigen Eingabedaten oder Entschl√ºsselungsfehlern
        """
        try:
            # Base64 dekodieren
            data = base64.urlsafe_b64decode(encrypted_data.encode("utf-8"))
            
            # Komponenten extrahieren (IV: 12 Bytes, Tag: 16 Bytes)
            if len(data) < 28:  # Mindestens IV + Tag
                raise ValueError("Encrypted data too short")
                
            iv = data[:12]
            tag = data[12:28]
            ciphertext = data[28:]
            
            # Cipher mit AES-256-GCM erstellen
            decryptor = Cipher(
                algorithms.AES(self._encryption_key),
                modes.GCM(iv, tag),
                backend=default_backend(),
            ).decryptor()
            
            # Entschl√ºsseln
            decrypted_bytes = decryptor.update(ciphertext) + decryptor.finalize()
            decrypted_text = decrypted_bytes.decode("utf-8")
            
            # JSON zu Dict konvertieren
            return json.loads(decrypted_text)
            
        except (InvalidTag, ValueError, UnicodeDecodeError, json.JSONDecodeError) as e:
            raise ValueError(f"Decryption failed: {str(e)}")
```

### 4.2 FastAPI Webhook Handler modifizieren

```python
from utils.encryption import PayloadDecryption

# In lifespan function
app.state.payload_decryption = PayloadDecryption()

@app.post("/webhook/endpoint")
async def webhook_handler(request: Request):
    payload_decryption = app.state.payload_decryption
    
    # Header pr√ºfen f√ºr Verschl√ºsselung
    is_encrypted = request.headers.get("X-Payload-Encrypted") == "true"
    
    try:
        if is_encrypted:
            # Verschl√ºsselter Payload: text/plain Format mit Base64-String
            encrypted_data = await request.body()
            encrypted_string = encrypted_data.decode("utf-8")
            
            try:
                payload = payload_decryption.decrypt_payload(encrypted_string)
            except ValueError as e:
                logger.error("Entschl√ºsselungsfehler: {error}", error=str(e))
                raise HTTPException(status_code=400, detail="Payload decryption failed")
        else:
            # Unverschl√ºsselter Payload: JSON Format (R√ºckw√§rtskompatibilit√§t)
            payload = await request.json()
            
        # Normale Verarbeitung mit entschl√ºsseltem payload
        # ...
        
    except (IndexError, KeyError, TypeError):
        raise HTTPException(status_code=400, detail="Ung√ºltiges Payload-Format")
    except Exception as e:
        logger.error("Fehler beim Verarbeiten des Payloads: {error}", error=str(e))
        raise HTTPException(status_code=400, detail="Payload processing failed")
```

## 5. Protokoll-Spezifikation

### 5.1 Verschl√ºsseltes Format

```
Header:
- Content-Type: text/plain
- X-Payload-Encrypted: true

Body:
- Base64-kodierter String
- Format: IV (12 bytes) + Tag (16 bytes) + Ciphertext (variable)
```

### 5.2 Unverschl√ºsseltes Format (R√ºckw√§rtskompatibilit√§t)

```
Header:
- Content-Type: application/json
- X-Payload-Encrypted: false (oder nicht gesetzt)

Body:
- Standard JSON Payload
```

## 6. Sicherheits-Features

### 6.1 Authentizit√§t & Integrit√§t
- AES-256-GCM bietet automatische Authentifizierung
- InvalidTag Exception bei manipulierten Daten

### 6.2 Fail-Safe Mechanismen
- HTTP 400 bei Entschl√ºsselungsfehlern
- Ausf√ºhrliche Fehler-Logs f√ºr Debugging
- R√ºckw√§rtskompatibilit√§t mit unverschl√ºsselten Payloads

### 6.3 GDPR-Konformit√§t
- Verschl√ºsselung sensibler Daten in Transit
- Sichere Schl√ºssel-Verwaltung √ºber Environment Variables
- Keine Klartext-Logs von sensiblen Daten

## 7. Testing

### 7.1 Test-Script erstellen

```python
#!/usr/bin/env python3
import os
import json
import asyncio
from dotenv import load_dotenv
from utils.encryption import PayloadDecryption, encrypt_payload

load_dotenv()

async def test_encryption():
    # Test-Payload
    test_payload = [{"objectId": "12345", "eventId": "test-123"}]
    
    # Verschl√ºsseln
    encrypted = encrypt_payload(test_payload)
    print(f"‚úÖ Payload verschl√ºsselt: {encrypted[:50]}...")
    
    # Entschl√ºsseln
    decryption = PayloadDecryption()
    decrypted = decryption.decrypt_payload(encrypted)
    
    # Vergleichen
    assert test_payload == decrypted
    print("‚úÖ Ver- und Entschl√ºsselung erfolgreich!")

if __name__ == "__main__":
    asyncio.run(test_encryption())
```

### 7.2 Tests ausf√ºhren

```bash
# Mit lokaler Conda Environment
./.conda/bin/python test_encryption.py

# Erwartete Ausgabe:
# ‚úÖ Payload verschl√ºsselt: WP1kow2TZ4jIVualJt9qouUmEnJJYBVjhcjjFjkvs72GKzha4A...
# ‚úÖ Ver- und Entschl√ºsselung erfolgreich!
```

## 8. Deployment Checklist

### 8.1 Vor Deployment pr√ºfen

- [ ] `PAYLOAD_ENCRYPTION_KEY` in allen Environments gesetzt
- [ ] `cryptography` Dependency installiert
- [ ] Tests erfolgreich durchgef√ºhrt
- [ ] Logging f√ºr Verschl√ºsselungs-Status implementiert

### 8.2 Rollout-Strategie

1. **Phase 1**: Empf√§nger-Service deployen (unterst√ºtzt beide Formate)
2. **Phase 2**: Sender-Service upgraden (sendet verschl√ºsselte Payloads)
3. **Phase 3**: Monitoring & Validation

### 8.3 Monitoring

```python
# Logging f√ºr Verschl√ºsselungs-Status
logger.info(
    "Webhook empfangen. Verschl√ºsselt: {encrypted}",
    encrypted=is_encrypted,
    task_name=task_name
)
```

## 9. Troubleshooting

### 9.1 H√§ufige Fehler

| Fehler | Ursache | L√∂sung |
|--------|---------|--------|
| `PAYLOAD_ENCRYPTION_KEY environment variable is required` | Fehlende Environment Variable | Key in .env setzen |
| `Invalid PAYLOAD_ENCRYPTION_KEY: Incorrect padding` | Ung√ºltiger Base64 Key | Neuen Key generieren |
| `Payload decryption failed` | Manipulierte Daten oder falscher Key | Key & Datenintegrit√§t pr√ºfen |
| `Encrypted data too short` | Unvollst√§ndige √úbertragung | Netzwerk & Task-Queue pr√ºfen |

### 9.2 Debug-Logging

```python
logger.debug(
    "Entschl√ºsselung gestartet. Daten-L√§nge: {length}",
    length=len(encrypted_data)
)
```

## 10. Wartung & Updates

### 10.1 Key-Rotation (falls erforderlich)

1. Neuen Key generieren
2. Beide Keys parallel unterst√ºtzen (√úbergangszeit)
3. Alten Key nach √úbergangszeit entfernen

### 10.2 Monitoring-Metriken

- Verschl√ºsselungs-/Entschl√ºsselungsrate
- Fehlerrate bei Entschl√ºsselung
- Performance-Impact

---

**üìö Weitere Dokumentation:**
- [AES-256-GCM Implementation Guide](./aes_256_gcm_implementation.md)
- [GDPR Logging Guidelines](./GDPR_LOGGING_IMPLEMENTATION_TEMPLATE.md)# Payload-Verschl√ºsselung Implementation Guide

## √úbersicht

Diese Anleitung beschreibt die Implementierung einer GDPR-konformen AES-256-GCM Payload-Verschl√ºsselung f√ºr HubSpot Webhook-Systeme. Die L√∂sung erm√∂glicht es, sensible Webhook-Daten verschl√ºsselt √ºber Cloud Tasks zu √ºbertragen.

## Architektur

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    verschl√ºsselt     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    entschl√ºsselt     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Sender        ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ  Cloud Tasks    ‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ ‚îÇ   Empf√§nger     ‚îÇ
‚îÇ   (Webhook)     ‚îÇ                      ‚îÇ   Queue         ‚îÇ                      ‚îÇ   (Processor)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## 1. Environment Setup

### 1.1 Verschl√ºsselungsschl√ºssel generieren

```bash
# Einmaliger Befehl zur Schl√ºssel-Generierung
python3 -c "import os, base64; print(base64.urlsafe_b64encode(os.urandom(32)).decode())"
```

### 1.2 Environment Variable setzen

```bash
# In .env Datei
PAYLOAD_ENCRYPTION_KEY=YOUR_GENERATED_KEY_HERE
```

## 2. Dependencies

### 2.1 Requirements.txt erweitern

```python
# In requirements.txt hinzuf√ºgen
cryptography
```

### 2.2 Installation

```bash
pip install cryptography
```

## 3. Sender-Implementation (Verschl√ºsselung)

### 3.1 Encryption Module erstellen

Erstelle `utils/encryption.py` mit folgenden Funktionen:

```python
import base64
import json
import os
from typing import Dict, Any
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend


def encrypt_payload(payload: Dict[Any, Any]) -> str:
    """
    Verschl√ºsselt einen Payload mit AES-256-GCM.
    
    Args:
        payload: Dict der verschl√ºsselt werden soll
        
    Returns:
        str: Base64-kodierter verschl√ºsselter String
    """
    encryption_key = os.getenv("PAYLOAD_ENCRYPTION_KEY")
    if not encryption_key:
        raise ValueError("PAYLOAD_ENCRYPTION_KEY environment variable is required")
    
    try:
        key = base64.urlsafe_b64decode(encryption_key)
        if len(key) != 32:
            raise ValueError("PAYLOAD_ENCRYPTION_KEY must be a 32-byte, base64-encoded key")
    except (ValueError, TypeError) as e:
        raise ValueError(f"Invalid PAYLOAD_ENCRYPTION_KEY: {str(e)}")
    
    # Payload zu JSON String konvertieren
    json_data = json.dumps(payload, ensure_ascii=False)
    
    # Frische 12-Byte IV f√ºr jede Verschl√ºsselung
    iv = os.urandom(12)
    
    # Cipher mit AES-256-GCM erstellen
    encryptor = Cipher(
        algorithms.AES(key),
        modes.GCM(iv),
        backend=default_backend(),
    ).encryptor()
    
    # Verschl√ºsseln
    ciphertext = encryptor.update(json_data.encode("utf-8")) + encryptor.finalize()
    
    # IV + Tag + Ciphertext kombinieren und Base64 kodieren
    encrypted_data = iv + encryptor.tag + ciphertext
    return base64.urlsafe_b64encode(encrypted_data).decode("utf-8")
```

### 3.2 Sender-Service modifizieren

```python
from utils.encryption import encrypt_payload

async def send_encrypted_webhook(payload: dict):
    """Webhook mit verschl√ºsseltem Payload senden"""
    
    # Payload verschl√ºsseln
    encrypted_payload = encrypt_payload(payload)
    
    # Task mit verschl√ºsseltem Payload erstellen
    task = {
        'http_request': {
            'http_method': tasks_v2.HttpMethod.POST,
            'url': webhook_url,
            'headers': {
                'Content-Type': 'text/plain',
                'X-Payload-Encrypted': 'true'  # Wichtiger Header!
            },
            'body': encrypted_payload.encode('utf-8')
        }
    }
    
    # Task zur Queue hinzuf√ºgen
    client.create_task(parent=parent, task=task)
```

## 4. Empf√§nger-Implementation (Entschl√ºsselung)

### 4.1 Decryption Class erstellen

Erg√§nze `utils/encryption.py`:

```python
from cryptography.exceptions import InvalidTag


class PayloadDecryption:
    """GDPR-konforme Entschl√ºsselungslogik f√ºr verschl√ºsselte Payloads."""
    
    def __init__(self):
        encryption_key = os.getenv("PAYLOAD_ENCRYPTION_KEY")
        if not encryption_key:
            raise ValueError("PAYLOAD_ENCRYPTION_KEY environment variable is required")
        
        try:
            self._encryption_key = base64.urlsafe_b64decode(encryption_key)
            if len(self._encryption_key) != 32:
                raise ValueError("PAYLOAD_ENCRYPTION_KEY must be a 32-byte, base64-encoded key")
        except (ValueError, TypeError) as e:
            raise ValueError(f"Invalid PAYLOAD_ENCRYPTION_KEY: {str(e)}")
    
    def decrypt_payload(self, encrypted_data: str) -> Dict[Any, Any]:
        """
        Entschl√ºsselt einen AES-256-GCM verschl√ºsselten Payload.
        
        Args:
            encrypted_data: Base64-kodierter String mit IV + Tag + Ciphertext
            
        Returns:
            Dict: Entschl√ºsselte Payload-Daten
            
        Raises:
            ValueError: Bei ung√ºltigen Eingabedaten oder Entschl√ºsselungsfehlern
        """
        try:
            # Base64 dekodieren
            data = base64.urlsafe_b64decode(encrypted_data.encode("utf-8"))
            
            # Komponenten extrahieren (IV: 12 Bytes, Tag: 16 Bytes)
            if len(data) < 28:  # Mindestens IV + Tag
                raise ValueError("Encrypted data too short")
                
            iv = data[:12]
            tag = data[12:28]
            ciphertext = data[28:]
            
            # Cipher mit AES-256-GCM erstellen
            decryptor = Cipher(
                algorithms.AES(self._encryption_key),
                modes.GCM(iv, tag),
                backend=default_backend(),
            ).decryptor()
            
            # Entschl√ºsseln
            decrypted_bytes = decryptor.update(ciphertext) + decryptor.finalize()
            decrypted_text = decrypted_bytes.decode("utf-8")
            
            # JSON zu Dict konvertieren
            return json.loads(decrypted_text)
            
        except (InvalidTag, ValueError, UnicodeDecodeError, json.JSONDecodeError) as e:
            raise ValueError(f"Decryption failed: {str(e)}")
```

### 4.2 FastAPI Webhook Handler modifizieren

```python
from utils.encryption import PayloadDecryption

# In lifespan function
app.state.payload_decryption = PayloadDecryption()

@app.post("/webhook/endpoint")
async def webhook_handler(request: Request):
    payload_decryption = app.state.payload_decryption
    
    # Header pr√ºfen f√ºr Verschl√ºsselung
    is_encrypted = request.headers.get("X-Payload-Encrypted") == "true"
    
    try:
        if is_encrypted:
            # Verschl√ºsselter Payload: text/plain Format mit Base64-String
            encrypted_data = await request.body()
            encrypted_string = encrypted_data.decode("utf-8")
            
            try:
                payload = payload_decryption.decrypt_payload(encrypted_string)
            except ValueError as e:
                logger.error("Entschl√ºsselungsfehler: {error}", error=str(e))
                raise HTTPException(status_code=400, detail="Payload decryption failed")
        else:
            # Unverschl√ºsselter Payload: JSON Format (R√ºckw√§rtskompatibilit√§t)
            payload = await request.json()
            
        # Normale Verarbeitung mit entschl√ºsseltem payload
        # ...
        
    except (IndexError, KeyError, TypeError):
        raise HTTPException(status_code=400, detail="Ung√ºltiges Payload-Format")
    except Exception as e:
        logger.error("Fehler beim Verarbeiten des Payloads: {error}", error=str(e))
        raise HTTPException(status_code=400, detail="Payload processing failed")
```

## 5. Protokoll-Spezifikation

### 5.1 Verschl√ºsseltes Format

```
Header:
- Content-Type: text/plain
- X-Payload-Encrypted: true

Body:
- Base64-kodierter String
- Format: IV (12 bytes) + Tag (16 bytes) + Ciphertext (variable)
```

### 5.2 Unverschl√ºsseltes Format (R√ºckw√§rtskompatibilit√§t)

```
Header:
- Content-Type: application/json
- X-Payload-Encrypted: false (oder nicht gesetzt)

Body:
- Standard JSON Payload
```

## 6. Sicherheits-Features

### 6.1 Authentizit√§t & Integrit√§t
- AES-256-GCM bietet automatische Authentifizierung
- InvalidTag Exception bei manipulierten Daten

### 6.2 Fail-Safe Mechanismen
- HTTP 400 bei Entschl√ºsselungsfehlern
- Ausf√ºhrliche Fehler-Logs f√ºr Debugging
- R√ºckw√§rtskompatibilit√§t mit unverschl√ºsselten Payloads

### 6.3 GDPR-Konformit√§t
- Verschl√ºsselung sensibler Daten in Transit
- Sichere Schl√ºssel-Verwaltung √ºber Environment Variables
- Keine Klartext-Logs von sensiblen Daten

## 7. Testing

### 7.1 Test-Script erstellen

```python
#!/usr/bin/env python3
import os
import json
import asyncio
from dotenv import load_dotenv
from utils.encryption import PayloadDecryption, encrypt_payload

load_dotenv()

async def test_encryption():
    # Test-Payload
    test_payload = [{"objectId": "12345", "eventId": "test-123"}]
    
    # Verschl√ºsseln
    encrypted = encrypt_payload(test_payload)
    print(f"‚úÖ Payload verschl√ºsselt: {encrypted[:50]}...")
    
    # Entschl√ºsseln
    decryption = PayloadDecryption()
    decrypted = decryption.decrypt_payload(encrypted)
    
    # Vergleichen
    assert test_payload == decrypted
    print("‚úÖ Ver- und Entschl√ºsselung erfolgreich!")

if __name__ == "__main__":
    asyncio.run(test_encryption())
```

### 7.2 Tests ausf√ºhren

```bash
# Mit lokaler Conda Environment
./.conda/bin/python test_encryption.py

# Erwartete Ausgabe:
# ‚úÖ Payload verschl√ºsselt: WP1kow2TZ4jIVualJt9qouUmEnJJYBVjhcjjFjkvs72GKzha4A...
# ‚úÖ Ver- und Entschl√ºsselung erfolgreich!
```

## 8. Deployment Checklist

### 8.1 Vor Deployment pr√ºfen

- [ ] `PAYLOAD_ENCRYPTION_KEY` in allen Environments gesetzt
- [ ] `cryptography` Dependency installiert
- [ ] Tests erfolgreich durchgef√ºhrt
- [ ] Logging f√ºr Verschl√ºsselungs-Status implementiert

### 8.2 Rollout-Strategie

1. **Phase 1**: Empf√§nger-Service deployen (unterst√ºtzt beide Formate)
2. **Phase 2**: Sender-Service upgraden (sendet verschl√ºsselte Payloads)
3. **Phase 3**: Monitoring & Validation

### 8.3 Monitoring

```python
# Logging f√ºr Verschl√ºsselungs-Status
logger.info(
    "Webhook empfangen. Verschl√ºsselt: {encrypted}",
    encrypted=is_encrypted,
    task_name=task_name
)
```

## 9. Troubleshooting

### 9.1 H√§ufige Fehler

| Fehler | Ursache | L√∂sung |
|--------|---------|--------|
| `PAYLOAD_ENCRYPTION_KEY environment variable is required` | Fehlende Environment Variable | Key in .env setzen |
| `Invalid PAYLOAD_ENCRYPTION_KEY: Incorrect padding` | Ung√ºltiger Base64 Key | Neuen Key generieren |
| `Payload decryption failed` | Manipulierte Daten oder falscher Key | Key & Datenintegrit√§t pr√ºfen |
| `Encrypted data too short` | Unvollst√§ndige √úbertragung | Netzwerk & Task-Queue pr√ºfen |

### 9.2 Debug-Logging

```python
logger.debug(
    "Entschl√ºsselung gestartet. Daten-L√§nge: {length}",
    length=len(encrypted_data)
)
```

## 10. Wartung & Updates

### 10.1 Key-Rotation (falls erforderlich)

1. Neuen Key generieren
2. Beide Keys parallel unterst√ºtzen (√úbergangszeit)
3. Alten Key nach √úbergangszeit entfernen

### 10.2 Monitoring-Metriken

- Verschl√ºsselungs-/Entschl√ºsselungsrate
- Fehlerrate bei Entschl√ºsselung
- Performance-Impact

---

**üìö Weitere Dokumentation:**
- [AES-256-GCM Implementation Guide](./aes_256_gcm_implementation.md)
- [GDPR Logging Guidelines](./GDPR_LOGGING_IMPLEMENTATION_TEMPLATE.md)